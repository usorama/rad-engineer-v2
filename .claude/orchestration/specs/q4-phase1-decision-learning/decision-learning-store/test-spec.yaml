# Test Specification: DecisionLearningStore

> **Component**: DecisionLearningStore
> **Phase**: Q4 Phase 1
> **Status**: Draft
> **Last Updated**: 2026-01-08

---

## 1. Test Requirements

### Coverage Requirements

| Metric | Target | Threshold |
|--------|--------|-----------|
| **Line Coverage** | ≥90% | PASS: ≥90%, FAIL: <80% |
| **Branch Coverage** | ≥85% | PASS: ≥85%, FAIL: <75% |
| **Function Coverage** | ≥95% | PASS: ≥95%, FAIL: <85% |

### Test Count Requirements

| Test Type | Minimum Count | Actual Count |
|-----------|---------------|--------------|
| Unit Tests | 30 | 0 (pending) |
| Integration Tests | 5 | 0 (pending) |
| Chaos Tests | 3 | 0 (pending) |

### Test Framework

- **Runtime**: Bun Test
- **Assertion Library**: Bun's built-in `expect()`
- **Mocking**: Manual mocks (no mocking library)

---

## 2. Unit Tests

### 2.1 storeDecision()

#### Test: store single decision

**Input**:
```typescript
const decision: DecisionRecord = {
  id: "test-decision-001",
  timestamp: Date.now(),
  component: "BanditRouter",
  activity: "routing",
  decision: "Use Anthropic for code domain",
  context: {
    domain: "code",
    complexity: 0.7,
    constraints: ["latency < 2s"],
    stakeholders: ["user"]
  },
  reasoningMethod: {
    name: "First Principles",
    category: "Core",
    parameters: {}
  },
  confidence: 0.9,
  importanceWeights: [0.5, 0.3, 0.2]
};
```

**Expected**:
- Decision stored successfully
- Query by ID returns the decision
- All fields preserved

**Assertions**:
```typescript
expect(store.getDecisions({ id: "test-decision-001" })).toHaveLength(1);
expect(store.getDecisions({ id: "test-decision-001" })[0]).toEqual(decision);
```

---

#### Test: reject duplicate decision ID

**Input**:
```typescript
const decision = { /* same decision as above */ };
store.storeDecision(decision);
store.storeDecision(decision); // Duplicate
```

**Expected**:
- Throws `DUPLICATE_DECISION_ID` error
- First decision still stored

**Assertions**:
```typescript
expect(() => store.storeDecision(decision)).toThrow("DUPLICATE_DECISION_ID");
expect(store.getDecisions()).toHaveLength(1);
```

---

#### Test: reject decision with missing required fields

**Input**:
```typescript
const invalidDecision = {
  id: "test-decision-002",
  // Missing: timestamp, component, activity, decision
  context: { domain: "code", complexity: 0.5, constraints: [], stakeholders: [] },
  reasoningMethod: { name: "5 Whys", category: "Core", parameters: {} },
  confidence: 0.8,
  importanceWeights: []
};
```

**Expected**:
- Throws `MISSING_REQUIRED_FIELDS` error
- No decision stored

**Assertions**:
```typescript
expect(() => store.storeDecision(invalidDecision)).toThrow("MISSING_REQUIRED_FIELDS");
expect(store.getDecisions()).toHaveLength(0);
```

---

#### Test: store 10,000 decisions with acceptable latency

**Input**:
```typescript
const decisions = Array.from({ length: 10000 }, (_, i) => createMockDecision(i));
const startTime = Date.now();
decisions.forEach(d => store.storeDecision(d));
const elapsed = Date.now() - startTime;
```

**Expected**:
- All 10,000 decisions stored
- Average latency <10ms per decision
- No storage errors

**Assertions**:
```typescript
expect(store.getDecisions()).toHaveLength(10000);
expect(elapsed / 10000).toBeLessThan(10); // <10ms avg
```

---

### 2.2 getDecisions()

#### Test: query all decisions (no filter)

**Input**:
```typescript
store.storeDecision(decision1);
store.storeDecision(decision2);
store.storeDecision(decision3);
const results = store.getDecisions();
```

**Expected**:
- Returns all 3 decisions
- Sorted by timestamp (newest first)

**Assertions**:
```typescript
expect(results).toHaveLength(3);
expect(results[0].timestamp).toBeGreaterThanOrEqual(results[1].timestamp);
```

---

#### Test: filter by component

**Input**:
```typescript
store.storeDecision({ component: "BanditRouter", /* ... */ });
store.storeDecision({ component: "PromptValidator", /* ... */ });
store.storeDecision({ component: "BanditRouter", /* ... */ });
const results = store.getDecisions({ component: "BanditRouter" });
```

**Expected**:
- Returns only BanditRouter decisions
- 2 results

**Assertions**:
```typescript
expect(results).toHaveLength(2);
expect(results.every(d => d.component === "BanditRouter")).toBe(true);
```

---

#### Test: filter by reasoning method

**Input**:
```typescript
store.storeDecision({ reasoningMethod: { name: "First Principles" }, /* ... */ });
store.storeDecision({ reasoningMethod: { name: "5 Whys" }, /* ... */ });
const results = store.getDecisions({ reasoningMethod: "First Principles" });
```

**Expected**:
- Returns only First Principles decisions
- 1 result

**Assertions**:
```typescript
expect(results).toHaveLength(1);
expect(results[0].reasoningMethod.name).toBe("First Principles");
```

---

#### Test: filter by date range

**Input**:
```typescript
const now = Date.now();
store.storeDecision({ timestamp: now - 1000, /* ... */ });
store.storeDecision({ timestamp: now, /* ... */ });
store.storeDecision({ timestamp: now + 1000, /* ... */ });
const results = store.getDecisions({
  dateRange: { start: now - 500, end: now + 500 }
});
```

**Expected**:
- Returns only decisions in range
- 1 result (the one at `now`)

**Assertions**:
```typescript
expect(results).toHaveLength(1);
expect(results[0].timestamp).toBe(now);
```

---

#### Test: query completes within 100ms (p95)

**Input**:
```typescript
// Store 1000 decisions
for (let i = 0; i < 1000; i++) {
  store.storeDecision(createMockDecision(i));
}

// Measure query latency
const latencies: number[] = [];
for (let i = 0; i < 100; i++) {
  const start = Date.now();
  store.getDecisions({ domain: "code" });
  latencies.push(Date.now() - start);
}

// Calculate p95
latencies.sort((a, b) => a - b);
const p95 = latencies[Math.floor(latencies.length * 0.95)];
```

**Expected**:
- p95 latency <100ms

**Assertions**:
```typescript
expect(p95).toBeLessThan(100);
```

---

### 2.3 learnFromOutcome()

#### Test: update decision with outcome

**Input**:
```typescript
const decisionId = "test-decision-003";
store.storeDecision({
  id: decisionId,
  /* ... */
});

const outcome: DecisionOutcome = {
  decisionId,
  success: true,
  quality: 0.95,
  latency: 150,
  cost: 0.002,
  errors: []
};

const update = store.learnFromOutcome(outcome);
```

**Expected**:
- Decision updated with outcome
- Method effectiveness updated
- Learning update returned

**Assertions**:
```typescript
const decision = store.getDecisions({ id: decisionId })[0];
expect(decision.outcome).toEqual(outcome);
expect(update.methodEffectiveness).toBeGreaterThan(0);
```

---

#### Test: throw error if decision not found

**Input**:
```typescript
const outcome: DecisionOutcome = {
  decisionId: "non-existent-id",
  success: true,
  quality: 0.8,
  errors: []
};
```

**Expected**:
- Throws `DECISION_NOT_FOUND` error

**Assertions**:
```typescript
expect(() => store.learnFromOutcome(outcome)).toThrow("DECISION_NOT_FOUND");
```

---

#### Test: learning converges after 100 outcomes

**Input**:
```typescript
// Store 100 decisions with same context
for (let i = 0; i < 100; i++) {
  const decision = createMockDecision(i, {
    domain: "code",
    complexity: 0.5
  });
  store.storeDecision(decision);

  // Simulate outcome
  const outcome = createMockOutcome(decision.id, {
    success: i % 2 === 0, // Alternating success
    quality: 0.7 + Math.random() * 0.2
  });
  store.learnFromOutcome(outcome);
}

// Get final effectiveness score
const method = store.getBestMethod({ domain: "code", complexity: 0.5, constraints: [], stakeholders: [] });
const finalScore = method.effectiveness;
```

**Expected**:
- Effectiveness score converges (delta <0.01)
- Score reflects actual success rate (~50%)

**Assertions**:
```typescript
// After 100 updates, score should be stable
// We can't test exact convergence without running, but we can test
// that the method returns a valid score
expect(finalScore).toBeGreaterThanOrEqual(0);
expect(finalScore).toBeLessThanOrEqual(1);
```

---

### 2.4 getBestMethod()

#### Test: return First Principles for unknown context

**Input**:
```typescript
const method = store.getBestMethod({
  domain: "creative",
  complexity: 0.9,
  constraints: [],
  stakeholders: []
});
```

**Expected**:
- Returns First Principles (default)
- Method has valid structure

**Assertions**:
```typescript
expect(method.name).toBe("First Principles");
expect(method.category).toBe("Core");
```

---

#### Test: recommend best method from history

**Input**:
```typescript
// Store decisions with First Principles (80% success)
for (let i = 0; i < 50; i++) {
  const decision = createMockDecision(i, { domain: "code", complexity: 0.5 });
  decision.reasoningMethod = { name: "First Principles", category: "Core", parameters: {} };
  store.storeDecision(decision);
  store.learnFromOutcome(createMockOutcome(decision.id, { success: i < 40, quality: 0.8 }));
}

// Store decisions with 5 Whys (40% success)
for (let i = 0; i < 50; i++) {
  const decision = createMockDecision(50 + i, { domain: "code", complexity: 0.5 });
  decision.reasoningMethod = { name: "5 Whys", category: "Core", parameters: {} };
  store.storeDecision(decision);
  store.learnFromOutcome(createMockOutcome(decision.id, { success: i < 20, quality: 0.7 }));
}

const method = store.getBestMethod({ domain: "code", complexity: 0.5, constraints: [], stakeholders: [] });
```

**Expected**:
- Recommends First Principles (higher success rate)
- Effectiveness score reflects 80% success

**Assertions**:
```typescript
expect(method.name).toBe("First Principles");
expect(method.effectiveness).toBeCloseTo(0.8, 1);
```

---

#### Test: recommendation improves success rate by >10%

**Input**:
```typescript
// Same setup as above test
// Then simulate 100 new decisions with recommended vs random method
let recommendedSuccess = 0;
let randomSuccess = 0;

for (let i = 0; i < 100; i++) {
  // Use recommended method
  const recommendedMethod = store.getBestMethod({ domain: "code", complexity: 0.5, constraints: [], stakeholders: [] });
  const recommendedDecision = createMockDecision(1000 + i, { domain: "code", complexity: 0.5 });
  recommendedDecision.reasoningMethod = recommendedMethod;
  store.storeDecision(recommendedDecision);
  const recommendedOutcome = createMockOutcome(recommendedDecision.id, { success: Math.random() < 0.8 });
  recommendedSuccess += recommendedOutcome.success ? 1 : 0;
  store.learnFromOutcome(recommendedOutcome);

  // Use random method
  const randomMethod = Math.random() > 0.5 ? { name: "First Principles", category: "Core" } : { name: "5 Whys", category: "Core" };
  const randomDecision = createMockDecision(2000 + i, { domain: "code", complexity: 0.5 });
  randomDecision.reasoningMethod = randomMethod;
  store.storeDecision(randomDecision);
  const randomOutcome = createMockOutcome(randomDecision.id, { success: Math.random() < 0.6 });
  randomSuccess += randomOutcome.success ? 1 : 0;
  store.learnFromOutcome(randomOutcome);
}

const recommendedRate = recommendedSuccess / 100;
const randomRate = randomSuccess / 100;
const improvement = (recommendedRate - randomRate) / randomRate;
```

**Expected**:
- Recommended method improves success rate by >10%

**Assertions**:
```typescript
expect(improvement).toBeGreaterThan(0.10); // >10% improvement
```

---

### 2.5 applyEWC()

#### Test: prevent catastrophic forgetting

**Input**:
```typescript
// Phase 1: Learn pattern A (code domain → First Principles)
for (let i = 0; i < 50; i++) {
  const decision = createMockDecision(i, { domain: "code", complexity: 0.5 });
  decision.reasoningMethod = { name: "First Principles", category: "Core", parameters: {} };
  store.storeDecision(decision);
  store.learnFromOutcome(createMockOutcome(decision.id, { success: true, quality: 0.9 }));
}

const snapshot = store.getCurrentSnapshot();

// Phase 2: Learn pattern B (creative domain → Tree of Thoughts)
for (let i = 0; i < 100; i++) {
  const decision = createMockDecision(100 + i, { domain: "creative", complexity: 0.8 });
  decision.reasoningMethod = { name: "Tree of Thoughts", category: "Advanced", parameters: {} };
  store.storeDecision(decision);
  store.learnFromOutcome(createMockOutcome(decision.id, { success: true, quality: 0.85 }));
}

// Query pattern A again
const method = store.getBestMethod({ domain: "code", complexity: 0.5, constraints: [], stakeholders: [] });
const accuracy = method.effectiveness;
```

**Expected**:
- Pattern A still accurate (>90%)
- EWC prevented catastrophic forgetting

**Assertions**:
```typescript
expect(accuracy).toBeGreaterThan(0.90); // >90% accuracy retained
```

---

#### Test: throw error if snapshot checksum invalid

**Input**:
```typescript
const corruptedSnapshot: DecisionSnapshot = {
  version: "v1",
  timestamp: Date.now(),
  checksum: "invalid-checksum",
  decisions: []
};
```

**Expected**:
- Throws `SNAPSHOT_INVALID` error

**Assertions**:
```typescript
expect(() => store.applyEWC(corruptedSnapshot)).toThrow("SNAPSHOT_INVALID");
```

---

### 2.6 exportToKnowledgeGraph()

#### Test: export all decisions with embeddings

**Input**:
```typescript
for (let i = 0; i < 100; i++) {
  store.storeDecision(createMockDecision(i));
}

const batch = await store.exportToKnowledgeGraph();
```

**Expected**:
- All 100 decisions exported
- Each decision has embedding vector
- Batch format valid for Qdrant

**Assertions**:
```typescript
expect(batch.batch.length).toBe(100);
batch.batch.forEach(item => {
  expect(item.vector).toBeDefined();
  expect(item.vector.length).toBeGreaterThan(0);
});
```

---

#### Test: handle Qdrant connection failure gracefully

**Input**:
```typescript
// Mock Qdrant client to throw connection error
mockQdrantClient.upsert.mockRejectedValue(new Error("Connection failed"));

await expect(store.exportToKnowledgeGraph()).rejects.toThrow("QDRANT_CONNECTION_FAILED");
```

**Expected**:
- Throws `QDRANT_CONNECTION_FAILED` error
- Retries 3x with exponential backoff

**Assertions**:
```typescript
expect(mockQdrantClient.upsert).toHaveBeenCalledTimes(3);
```

---

## 3. Integration Tests

### 3.1 DecisionTracker integration

**Test**: DecisionTracker creates decisions → DecisionLearningStore stores them

**Setup**:
```typescript
const decisionTracker = new DecisionTracker();
const decisionStore = new DecisionLearningStore();

decisionTracker.on('decision', (decision) => {
  decisionStore.storeDecision(decision);
});

// Trigger a decision
decisionTracker.recordDecision({
  component: "BanditRouter",
  activity: "routing",
  decision: "Use Anthropic for code domain",
  context: { domain: "code", complexity: 0.7, constraints: [], stakeholders: ["user"] },
  reasoningMethod: { name: "First Principles", category: "Core", parameters: {} }
});
```

**Expected**:
- Decision stored in DecisionLearningStore
- Query returns the decision

**Assertions**:
```typescript
const decisions = decisionStore.getDecisions({ component: "BanditRouter" });
expect(decisions).toHaveLength(1);
expect(decisions[0].decision).toBe("Use Anthropic for code domain");
```

---

### 3.2 OutcomeInjector integration

**Test**: OutcomeInjector queries best method → DecisionLearningStore provides recommendation

**Setup**:
```typescript
const outcomeInjector = new OutcomeInjector();
const decisionStore = new DecisionLearningStore();

// Seed decision store with historical data
for (let i = 0; i < 50; i++) {
  const decision = createMockDecision(i, { domain: "code", complexity: 0.5 });
  decision.reasoningMethod = { name: "First Principles", category: "Core", parameters: {} };
  decisionStore.storeDecision(decision);
  decisionStore.learnFromOutcome(createMockOutcome(decision.id, { success: true, quality: 0.85 }));
}

outcomeInjector.setDecisionStore(decisionStore);

// Query best method
const method = outcomeInjector.getBestMethodForContext({
  domain: "code",
  complexity: 0.5,
  constraints: [],
  stakeholders: []
});
```

**Expected**:
- OutcomeInjector returns First Principles
- Effectiveness score >0.8

**Assertions**:
```typescript
expect(method.name).toBe("First Principles");
expect(method.effectiveness).toBeGreaterThan(0.8);
```

---

### 3.3 Knowledge Graph integration

**Test**: DecisionLearningStore exports → Qdrant stores → semantic search works

**Setup**:
```typescript
const decisionStore = new DecisionLearningStore();
const qdrantClient = new QdrantClient();

// Store and export decisions
for (let i = 0; i < 100; i++) {
  decisionStore.storeDecision(createMockDecision(i));
}
const batch = await decisionStore.exportToKnowledgeGraph();
await qdrantClient.upsert(batch);

// Semantic search
const results = await qdrantClient.search({
  collection: "decisions",
  query: "routing decisions for code domain",
  limit: 5
});
```

**Expected**:
- Semantic search returns relevant decisions
- Results include decisions about routing and code domain

**Assertions**:
```typescript
expect(results.length).toBeGreaterThan(0);
expect(results.some(r => r.payload.decision.includes("routing"))).toBe(true);
```

---

### 3.4 End-to-end learning loop

**Test**: Decision → Outcome → Learning → Better Decisions

**Setup**:
```typescript
const decisionStore = new DecisionLearningStore();

// Phase 1: Initial decisions (random methods)
for (let i = 0; i < 50; i++) {
  const decision = createMockDecision(i, { domain: "code", complexity: 0.5 });
  decision.reasoningMethod = Math.random() > 0.5
    ? { name: "First Principles", category: "Core", parameters: {} }
    : { name: "5 Whys", category: "Core", parameters: {} };
  decisionStore.storeDecision(decision);
  const outcome = createMockOutcome(decision.id, {
    success: decision.reasoningMethod.name === "First Principles",
    quality: decision.reasoningMethod.name === "First Principles" ? 0.9 : 0.7
  });
  decisionStore.learnFromOutcome(outcome);
}

// Phase 2: Use learned recommendations
let recommendedSuccess = 0;
for (let i = 0; i < 50; i++) {
  const bestMethod = decisionStore.getBestMethod({ domain: "code", complexity: 0.5, constraints: [], stakeholders: [] });
  const decision = createMockDecision(100 + i, { domain: "code", complexity: 0.5 });
  decision.reasoningMethod = bestMethod;
  decisionStore.storeDecision(decision);
  const outcome = createMockOutcome(decision.id, {
    success: bestMethod.name === "First Principles",
    quality: 0.85
  });
  recommendedSuccess += outcome.success ? 1 : 0;
  decisionStore.learnFromOutcome(outcome);
}

const successRate = recommendedSuccess / 50;
```

**Expected**:
- Recommended methods achieve >80% success rate
- Learning loop improved decision quality

**Assertions**:
```typescript
expect(successRate).toBeGreaterThan(0.80);
```

---

### 3.5 Persistence and recovery

**Test**: Decisions persist to disk → Reload → Data integrity maintained

**Setup**:
```typescript
const decisionStore = new DecisionLearningStore({ savePath: "/tmp/test-decisions.json" });

// Store decisions
for (let i = 0; i < 100; i++) {
  decisionStore.storeDecision(createMockDecision(i));
}

// Save to disk
await decisionStore.save();

// Load into new instance
const reloadedStore = new DecisionLearningStore({ savePath: "/tmp/test-decisions.json" });
await reloadedStore.load();

// Verify data integrity
const originalDecisions = decisionStore.getDecisions();
const reloadedDecisions = reloadedStore.getDecisions();
```

**Expected**:
- All 100 decisions recovered
- Data integrity maintained (checksum matches)
- No data corruption

**Assertions**:
```typescript
expect(reloadedDecisions).toHaveLength(100);
expect(reloadedDecisions).toEqual(originalDecisions);
expect(reloadedStore.getCurrentChecksum()).toBe(decisionStore.getCurrentChecksum());
```

---

## 4. Chaos Tests

### 4.1 Concurrent decision storage

**Test**: 100 concurrent store operations → No race conditions, all decisions stored

**Setup**:
```typescript
const decisionStore = new DecisionLearningStore();
const promises = Array.from({ length: 100 }, (_, i) =>
  decisionStore.storeDecision(createMockDecision(i))
);

await Promise.all(promises);
```

**Expected**:
- All 100 decisions stored
- No duplicate IDs
- No data corruption

**Assertions**:
```typescript
const decisions = decisionStore.getDecisions();
expect(decisions).toHaveLength(100);
expect(new Set(decisions.map(d => d.id)).size).toBe(100); // No duplicates
```

---

### 4.2 Storage failure during bulk operation

**Test**: Disk write fails mid-batch → Graceful recovery, partial rollback

**Setup**:
```typescript
const decisionStore = new DecisionLearningStore();

// Mock fs.writeFile to fail on 50th write
let writeCount = 0;
mockFs.writeFile.mockImplementation(((path, data, cb) => {
  writeCount++;
  if (writeCount === 50) {
    cb(new Error("Disk full"));
  } else {
    cb(null);
  }
}) as any);

// Try to store 100 decisions
for (let i = 0; i < 100; i++) {
  try {
    decisionStore.storeDecision(createMockDecision(i));
  } catch (e) {
    // Expected to fail on 50th
    if (i !== 49) throw e;
  }
}
```

**Expected**:
- 49 decisions stored successfully
- 50th decision rejected with error
- No partial writes or corruption

**Assertions**:
```typescript
expect(decisionStore.getDecisions()).toHaveLength(49);
```

---

### 4.3 Memory pressure with 100k decisions

**Test**: Store 100,000 decisions → Memory usage acceptable, performance degrades gracefully

**Setup**:
```typescript
const decisionStore = new DecisionLearningStore();

const startMemory = process.memoryUsage().heapUsed;

for (let i = 0; i < 100000; i++) {
  decisionStore.storeDecision(createMockDecision(i));
}

const endMemory = process.memoryUsage().heapUsed;
const memoryDelta = endMemory - startMemory;
const memoryPerDecision = memoryDelta / 100000;
```

**Expected**:
- Memory per decision <1KB
- Total memory <100MB
- No memory leaks

**Assertions**:
```typescript
expect(memoryPerDecision).toBeLessThan(1024); // <1KB per decision
expect(memoryDelta).toBeLessThan(100 * 1024 * 1024); // <100MB total
```

---

## 5. Success Criteria Mapping

| Criterion | Test Coverage |
|-----------|---------------|
| Criterion 1: Decision storage <100ms | Unit Test 2.2.5 (query latency) |
| Criterion 2: Learning converges in 100 updates | Unit Test 2.3.3 (convergence) |
| Criterion 3: EWC prevents forgetting | Unit Test 2.5.1 (EWC effectiveness) |
| Criterion 4: Knowledge graph export | Unit Test 2.6.1 + Integration 3.3 |
| Criterion 5: Best method improves success >10% | Unit Test 2.4.3 (improvement) |
| Criterion 6: TypeScript 0 errors | N/A (run `bun typecheck`) |

---

## 6. Verification Commands

```bash
# Run all tests
cd rad-engineer && bun test

# Run only DecisionLearningStore tests
cd rad-engineer && bun test test/decision/DecisionLearningStore.test.ts

# Check coverage
cd rad-engineer && bun run test:coverage

# Type check
cd rad-engineer && bun run typecheck

# Lint
cd rad-engineer && bun run lint
```

---

**Status**: Ready for implementation
**Total Tests**: 30 unit + 5 integration + 3 chaos = 38 tests
**Coverage Target**: ≥90% lines, ≥85% branches, ≥95% functions
