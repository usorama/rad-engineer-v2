import { ipcMain } from 'electron';
import type { BrowserWindow } from 'electron';
import path from 'path';
import { existsSync, readFileSync } from 'fs';
import { execSync } from 'child_process';
import { IPC_CHANNELS, getSpecsDir } from '../../shared/constants';
import type {
  IPCResult,
  Task,
  ChangelogTask,
  TaskSpecContent,
  ChangelogGenerationRequest,
  ChangelogSaveRequest,
  ChangelogSaveResult,
  ExistingChangelog,
  GitBranchInfo,
  GitTagInfo,
  GitCommit,
  GitHistoryOptions,
  BranchDiffOptions
} from '../../shared/types';
import { projectStore } from '../project-store';
import { changelogService } from '../changelog-service';

/**
 * Register all changelog-related IPC handlers
 */
export function registerChangelogHandlers(
  getMainWindow: () => BrowserWindow | null
): void {
  // Changelog Operations
  // ============================================

  ipcMain.handle(
    IPC_CHANNELS.CHANGELOG_GET_DONE_TASKS,
    async (_, projectId: string, rendererTasks?: import('../shared/types').Task[]): Promise<IPCResult<import('../shared/types').ChangelogTask[]>> => {
      const project = projectStore.getProject(projectId);
      if (!project) {
        return { success: false, error: 'Project not found' };
      }

      // Use renderer tasks if provided (they have the correct UI status),
      // otherwise fall back to reading from filesystem
      const tasks = rendererTasks || projectStore.getTasks(projectId);

      // Get specs directory path
      const specsBaseDir = getSpecsDir(project.autoBuildPath);
      const doneTasks = changelogService.getCompletedTasks(project.path, tasks, specsBaseDir);

      return { success: true, data: doneTasks };
    }
  );

  ipcMain.handle(
    IPC_CHANNELS.CHANGELOG_LOAD_TASK_SPECS,
    async (_, projectId: string, taskIds: string[]): Promise<IPCResult<import('../shared/types').TaskSpecContent[]>> => {
      const project = projectStore.getProject(projectId);
      if (!project) {
        return { success: false, error: 'Project not found' };
      }

      const tasks = projectStore.getTasks(projectId);

      // Get specs directory path
      const specsBaseDir = getSpecsDir(project.autoBuildPath);
      const specs = await changelogService.loadTaskSpecs(project.path, taskIds, tasks, specsBaseDir);

      return { success: true, data: specs };
    }
  );

  ipcMain.on(
    IPC_CHANNELS.CHANGELOG_GENERATE,
    async (_, request: import('../shared/types').ChangelogGenerationRequest) => {
      const mainWindow = getMainWindow();
      if (!mainWindow) return;

      const project = projectStore.getProject(request.projectId);
      if (!project) {
        mainWindow.webContents.send(
          IPC_CHANNELS.CHANGELOG_GENERATION_ERROR,
          request.projectId,
          'Project not found'
        );
        return;
      }

      // Load specs for selected tasks (only in tasks mode)
      let specs: import('../shared/types').TaskSpecContent[] = [];
      if (request.sourceMode === 'tasks' && request.taskIds && request.taskIds.length > 0) {
        const tasks = projectStore.getTasks(request.projectId);
        const specsBaseDir = getSpecsDir(project.autoBuildPath);
        specs = await changelogService.loadTaskSpecs(project.path, request.taskIds, tasks, specsBaseDir);
      }

      // Start generation
      changelogService.generateChangelog(request.projectId, project.path, request, specs);
    }
  );

  ipcMain.handle(
    IPC_CHANNELS.CHANGELOG_SAVE,
    async (_, request: import('../shared/types').ChangelogSaveRequest): Promise<IPCResult<import('../shared/types').ChangelogSaveResult>> => {
      const project = projectStore.getProject(request.projectId);
      if (!project) {
        return { success: false, error: 'Project not found' };
      }

      try {
        const result = changelogService.saveChangelog(project.path, request);
        return { success: true, data: result };
      } catch (error) {
        return {
          success: false,
          error: error instanceof Error ? error.message : 'Failed to save changelog'
        };
      }
    }
  );

  ipcMain.handle(
    IPC_CHANNELS.CHANGELOG_READ_EXISTING,
    async (_, projectId: string): Promise<IPCResult<import('../shared/types').ExistingChangelog>> => {
      const project = projectStore.getProject(projectId);
      if (!project) {
        return { success: false, error: 'Project not found' };
      }

      const result = changelogService.readExistingChangelog(project.path);
      return { success: true, data: result };
    }
  );

  ipcMain.handle(
    IPC_CHANNELS.CHANGELOG_SUGGEST_VERSION,
    async (_, projectId: string, taskIds: string[]): Promise<IPCResult<{ version: string; reason: string }>> => {
      const project = projectStore.getProject(projectId);
      if (!project) {
        return { success: false, error: 'Project not found' };
      }

      try {
        // Get current version from existing changelog
        const existing = changelogService.readExistingChangelog(project.path);
        const currentVersion = existing.lastVersion;

        // Load specs for selected tasks to analyze change types
        const tasks = projectStore.getTasks(projectId);
                const specsBaseDir = getSpecsDir(project.autoBuildPath);
        const specs = await changelogService.loadTaskSpecs(project.path, taskIds, tasks, specsBaseDir);

        // Analyze specs and suggest version
        const suggestedVersion = changelogService.suggestVersion(specs, currentVersion);

        // Determine reason for the suggestion
        let reason = 'patch';
        if (currentVersion) {
          const [oldMajor, oldMinor] = currentVersion.split('.').map(Number);
          const [newMajor, newMinor] = suggestedVersion.split('.').map(Number);
          if (newMajor > oldMajor) {
            reason = 'breaking';
          } else if (newMinor > oldMinor) {
            reason = 'feature';
          }
        }

        return {
          success: true,
          data: { version: suggestedVersion, reason }
        };
      } catch (error) {
        return {
          success: false,
          error: error instanceof Error ? error.message : 'Failed to suggest version'
        };
      }
    }
  );

  // ============================================
  // Changelog Git Operations
  // ============================================

  ipcMain.handle(
    IPC_CHANNELS.CHANGELOG_GET_BRANCHES,
    async (_, projectId: string): Promise<IPCResult<import('../shared/types').GitBranchInfo[]>> => {
      const project = projectStore.getProject(projectId);
      if (!project) {
        return { success: false, error: 'Project not found' };
      }

      try {
        const branches = changelogService.getBranches(project.path);
        return { success: true, data: branches };
      } catch (error) {
        return {
          success: false,
          error: error instanceof Error ? error.message : 'Failed to get branches'
        };
      }
    }
  );

  ipcMain.handle(
    IPC_CHANNELS.CHANGELOG_GET_TAGS,
    async (_, projectId: string): Promise<IPCResult<import('../shared/types').GitTagInfo[]>> => {
      const project = projectStore.getProject(projectId);
      if (!project) {
        return { success: false, error: 'Project not found' };
      }

      try {
        const tags = changelogService.getTags(project.path);
        return { success: true, data: tags };
      } catch (error) {
        return {
          success: false,
          error: error instanceof Error ? error.message : 'Failed to get tags'
        };
      }
    }
  );

  ipcMain.handle(
    IPC_CHANNELS.CHANGELOG_GET_COMMITS_PREVIEW,
    async (
      _,
      projectId: string,
      options: import('../shared/types').GitHistoryOptions | import('../shared/types').BranchDiffOptions,
      mode: 'git-history' | 'branch-diff'
    ): Promise<IPCResult<import('../shared/types').GitCommit[]>> => {
      const project = projectStore.getProject(projectId);
      if (!project) {
        return { success: false, error: 'Project not found' };
      }

      try {
        let commits: import('../shared/types').GitCommit[];

        if (mode === 'git-history') {
          commits = changelogService.getCommits(
            project.path,
            options as import('../shared/types').GitHistoryOptions
          );
        } else {
          commits = changelogService.getBranchDiffCommits(
            project.path,
            options as import('../shared/types').BranchDiffOptions
          );
        }

        return { success: true, data: commits };
      } catch (error) {
        return {
          success: false,
          error: error instanceof Error ? error.message : 'Failed to get commits preview'
        };
      }
    }
  );

  // ============================================
  // Changelog Agent Events â†’ Renderer
}
