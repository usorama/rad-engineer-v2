/**
 * Unit tests for GitLab MR Review handlers
 * Tests review result parsing and finding transformations
 */
import { describe, it, expect } from 'vitest';

// Test types matching the handler's internal types
interface MRReviewFinding {
  id: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  category: string;
  title: string;
  description: string;
  file: string;
  line: number;
  endLine?: number;
  suggestedFix?: string;
  fixable: boolean;
}

interface MRReviewResult {
  mrIid: number;
  project: string;
  success: boolean;
  findings: MRReviewFinding[];
  summary: string;
  overallStatus: 'approve' | 'request_changes' | 'comment';
  reviewedAt: string;
  reviewedCommitSha?: string;
  isFollowupReview: boolean;
  previousReviewId?: string;
  resolvedFindings: string[];
  unresolvedFindings: string[];
  newFindingsSinceLastReview: string[];
  hasPostedFindings: boolean;
  postedFindingIds: string[];
}

interface RawReviewData {
  mr_iid: number;
  project: string;
  success: boolean;
  findings?: Array<{
    id: string;
    severity: string;
    category: string;
    title: string;
    description: string;
    file: string;
    line: number;
    end_line?: number;
    suggested_fix?: string;
    fixable?: boolean;
  }>;
  summary?: string;
  overall_status?: string;
  reviewed_at?: string;
  reviewed_commit_sha?: string;
  is_followup_review?: boolean;
  previous_review_id?: string;
  resolved_findings?: string[];
  unresolved_findings?: string[];
  new_findings_since_last_review?: string[];
  has_posted_findings?: boolean;
  posted_finding_ids?: string[];
}

/**
 * Parse raw review data from JSON file into MRReviewResult
 */
function parseReviewResult(data: RawReviewData): MRReviewResult {
  return {
    mrIid: data.mr_iid,
    project: data.project,
    success: data.success,
    findings: data.findings?.map((f) => ({
      id: f.id,
      severity: f.severity as MRReviewFinding['severity'],
      category: f.category,
      title: f.title,
      description: f.description,
      file: f.file,
      line: f.line,
      endLine: f.end_line,
      suggestedFix: f.suggested_fix,
      fixable: f.fixable ?? false,
    })) ?? [],
    summary: data.summary ?? '',
    overallStatus: (data.overall_status as MRReviewResult['overallStatus']) ?? 'comment',
    reviewedAt: data.reviewed_at ?? new Date().toISOString(),
    reviewedCommitSha: data.reviewed_commit_sha,
    isFollowupReview: data.is_followup_review ?? false,
    previousReviewId: data.previous_review_id,
    resolvedFindings: data.resolved_findings ?? [],
    unresolvedFindings: data.unresolved_findings ?? [],
    newFindingsSinceLastReview: data.new_findings_since_last_review ?? [],
    hasPostedFindings: data.has_posted_findings ?? false,
    postedFindingIds: data.posted_finding_ids ?? [],
  };
}

/**
 * Format review body for posting as GitLab note
 */
function formatReviewBody(result: MRReviewResult, selectedFindingIds?: string[]): string {
  const selectedSet = selectedFindingIds ? new Set(selectedFindingIds) : null;
  const findings = selectedSet
    ? result.findings.filter(f => selectedSet.has(f.id))
    : result.findings;

  let body = `## rad-engineer MR Review\n\n${result.summary}\n\n`;

  if (findings.length > 0) {
    const countText = selectedSet
      ? `${findings.length} selected of ${result.findings.length} total`
      : `${findings.length} total`;
    body += `### Findings (${countText})\n\n`;

    for (const f of findings) {
      const emoji = { critical: 'ðŸ”´', high: 'ðŸŸ ', medium: 'ðŸŸ¡', low: 'ðŸ”µ' }[f.severity] || 'âšª';
      body += `#### ${emoji} [${f.severity.toUpperCase()}] ${f.title}\n`;
      body += `ðŸ“ \`${f.file}:${f.line}\`\n\n`;
      body += `${f.description}\n\n`;
      const suggestedFix = f.suggestedFix?.trim();
      if (suggestedFix) {
        body += `**Suggested fix:**\n\`\`\`\n${suggestedFix}\n\`\`\`\n\n`;
      }
    }
  } else {
    body += `*No findings selected for this review.*\n\n`;
  }

  body += `---\n*This review was generated by rad-engineer.*`;

  return body;
}

describe('GitLab MR Review Handlers', () => {
  describe('parseReviewResult', () => {
    const baseRawData: RawReviewData = {
      mr_iid: 42,
      project: 'test/project',
      success: true,
      findings: [
        {
          id: 'finding-abc123',
          severity: 'high',
          category: 'security',
          title: 'SQL Injection Vulnerability',
          description: 'User input is directly concatenated into SQL query',
          file: 'src/db.ts',
          line: 42,
          end_line: 45,
          suggested_fix: 'Use parameterized queries',
          fixable: true
        }
      ],
      summary: 'Found 1 high severity issue',
      overall_status: 'request_changes',
      reviewed_at: '2024-01-15T10:00:00Z',
      reviewed_commit_sha: 'abc123def456',
      is_followup_review: false,
      resolved_findings: [],
      unresolved_findings: [],
      new_findings_since_last_review: [],
      has_posted_findings: false,
      posted_finding_ids: []
    };

    it('should parse basic review result correctly', () => {
      const result = parseReviewResult(baseRawData);

      expect(result.mrIid).toBe(42);
      expect(result.project).toBe('test/project');
      expect(result.success).toBe(true);
      expect(result.summary).toBe('Found 1 high severity issue');
      expect(result.overallStatus).toBe('request_changes');
    });

    it('should parse findings correctly', () => {
      const result = parseReviewResult(baseRawData);

      expect(result.findings).toHaveLength(1);
      expect(result.findings[0].id).toBe('finding-abc123');
      expect(result.findings[0].severity).toBe('high');
      expect(result.findings[0].category).toBe('security');
      expect(result.findings[0].title).toBe('SQL Injection Vulnerability');
      expect(result.findings[0].file).toBe('src/db.ts');
      expect(result.findings[0].line).toBe(42);
      expect(result.findings[0].endLine).toBe(45);
      expect(result.findings[0].suggestedFix).toBe('Use parameterized queries');
      expect(result.findings[0].fixable).toBe(true);
    });

    it('should parse commit SHA and timestamps', () => {
      const result = parseReviewResult(baseRawData);

      expect(result.reviewedAt).toBe('2024-01-15T10:00:00Z');
      expect(result.reviewedCommitSha).toBe('abc123def456');
    });

    it('should handle follow-up reviews', () => {
      const followupData: RawReviewData = {
        ...baseRawData,
        is_followup_review: true,
        previous_review_id: 'prev-review-123',
        resolved_findings: ['finding-old1', 'finding-old2'],
        unresolved_findings: ['finding-old3'],
        new_findings_since_last_review: ['finding-abc123']
      };

      const result = parseReviewResult(followupData);

      expect(result.isFollowupReview).toBe(true);
      expect(result.previousReviewId).toBe('prev-review-123');
      expect(result.resolvedFindings).toEqual(['finding-old1', 'finding-old2']);
      expect(result.unresolvedFindings).toEqual(['finding-old3']);
      expect(result.newFindingsSinceLastReview).toEqual(['finding-abc123']);
    });

    it('should handle posted findings state', () => {
      const postedData: RawReviewData = {
        ...baseRawData,
        has_posted_findings: true,
        posted_finding_ids: ['finding-abc123']
      };

      const result = parseReviewResult(postedData);

      expect(result.hasPostedFindings).toBe(true);
      expect(result.postedFindingIds).toEqual(['finding-abc123']);
    });

    it('should handle missing optional fields with defaults', () => {
      const minimalData: RawReviewData = {
        mr_iid: 1,
        project: 'test/project',
        success: true
      };

      const result = parseReviewResult(minimalData);

      expect(result.findings).toEqual([]);
      expect(result.summary).toBe('');
      expect(result.overallStatus).toBe('comment');
      expect(result.isFollowupReview).toBe(false);
      expect(result.resolvedFindings).toEqual([]);
      expect(result.unresolvedFindings).toEqual([]);
      expect(result.newFindingsSinceLastReview).toEqual([]);
      expect(result.hasPostedFindings).toBe(false);
      expect(result.postedFindingIds).toEqual([]);
    });

    it('should handle findings without suggested fix', () => {
      const noFixData: RawReviewData = {
        ...baseRawData,
        findings: [
          {
            id: 'finding-1',
            severity: 'low',
            category: 'style',
            title: 'Style issue',
            description: 'Code style violation',
            file: 'src/app.ts',
            line: 10
          }
        ]
      };

      const result = parseReviewResult(noFixData);

      expect(result.findings[0].suggestedFix).toBeUndefined();
      expect(result.findings[0].fixable).toBe(false);
    });

    it('should handle all severity levels', () => {
      const allSeverities: RawReviewData = {
        ...baseRawData,
        findings: [
          { id: '1', severity: 'critical', category: 'security', title: 'Critical', description: '', file: 'a.ts', line: 1 },
          { id: '2', severity: 'high', category: 'quality', title: 'High', description: '', file: 'b.ts', line: 2 },
          { id: '3', severity: 'medium', category: 'style', title: 'Medium', description: '', file: 'c.ts', line: 3 },
          { id: '4', severity: 'low', category: 'docs', title: 'Low', description: '', file: 'd.ts', line: 4 }
        ]
      };

      const result = parseReviewResult(allSeverities);

      expect(result.findings[0].severity).toBe('critical');
      expect(result.findings[1].severity).toBe('high');
      expect(result.findings[2].severity).toBe('medium');
      expect(result.findings[3].severity).toBe('low');
    });
  });

  describe('formatReviewBody', () => {
    const baseResult: MRReviewResult = {
      mrIid: 42,
      project: 'test/project',
      success: true,
      findings: [
        {
          id: 'finding-1',
          severity: 'high',
          category: 'security',
          title: 'SQL Injection',
          description: 'User input is not sanitized',
          file: 'src/db.ts',
          line: 42,
          suggestedFix: 'Use prepared statements',
          fixable: true
        },
        {
          id: 'finding-2',
          severity: 'medium',
          category: 'quality',
          title: 'Missing error handling',
          description: 'Promise rejection not handled',
          file: 'src/api.ts',
          line: 100,
          fixable: false
        }
      ],
      summary: 'Found 2 issues that need attention',
      overallStatus: 'request_changes',
      reviewedAt: '2024-01-15T10:00:00Z',
      isFollowupReview: false,
      resolvedFindings: [],
      unresolvedFindings: [],
      newFindingsSinceLastReview: [],
      hasPostedFindings: false,
      postedFindingIds: []
    };

    it('should format review header', () => {
      const body = formatReviewBody(baseResult);

      expect(body).toContain('## rad-engineer MR Review');
      expect(body).toContain('Found 2 issues that need attention');
    });

    it('should format all findings when no selection', () => {
      const body = formatReviewBody(baseResult);

      expect(body).toContain('### Findings (2 total)');
      expect(body).toContain('SQL Injection');
      expect(body).toContain('Missing error handling');
    });

    it('should format selected findings only', () => {
      const body = formatReviewBody(baseResult, ['finding-1']);

      expect(body).toContain('### Findings (1 selected of 2 total)');
      expect(body).toContain('SQL Injection');
      expect(body).not.toContain('Missing error handling');
    });

    it('should format severity emojis correctly', () => {
      const allSeveritiesResult: MRReviewResult = {
        ...baseResult,
        findings: [
          { id: '1', severity: 'critical', category: 'security', title: 'Critical Issue', description: '', file: 'a.ts', line: 1, fixable: false },
          { id: '2', severity: 'high', category: 'quality', title: 'High Issue', description: '', file: 'b.ts', line: 2, fixable: false },
          { id: '3', severity: 'medium', category: 'style', title: 'Medium Issue', description: '', file: 'c.ts', line: 3, fixable: false },
          { id: '4', severity: 'low', category: 'docs', title: 'Low Issue', description: '', file: 'd.ts', line: 4, fixable: false }
        ]
      };

      const body = formatReviewBody(allSeveritiesResult);

      expect(body).toContain('ðŸ”´ [CRITICAL] Critical Issue');
      expect(body).toContain('ðŸŸ  [HIGH] High Issue');
      expect(body).toContain('ðŸŸ¡ [MEDIUM] Medium Issue');
      expect(body).toContain('ðŸ”µ [LOW] Low Issue');
    });

    it('should format file locations', () => {
      const body = formatReviewBody(baseResult);

      expect(body).toContain('ðŸ“ `src/db.ts:42`');
      expect(body).toContain('ðŸ“ `src/api.ts:100`');
    });

    it('should format suggested fixes', () => {
      const body = formatReviewBody(baseResult);

      expect(body).toContain('**Suggested fix:**');
      expect(body).toContain('Use prepared statements');
    });

    it('should handle empty findings selection', () => {
      const body = formatReviewBody(baseResult, []);

      expect(body).toContain('*No findings selected for this review.*');
      expect(body).not.toContain('SQL Injection');
    });

    it('should handle result with no findings', () => {
      const noFindingsResult: MRReviewResult = {
        ...baseResult,
        findings: []
      };

      const body = formatReviewBody(noFindingsResult);

      expect(body).toContain('*No findings selected for this review.*');
    });

    it('should include footer', () => {
      const body = formatReviewBody(baseResult);

      expect(body).toContain('---');
      expect(body).toContain('*This review was generated by rad-engineer.*');
    });

    it('should format finding descriptions', () => {
      const body = formatReviewBody(baseResult);

      expect(body).toContain('User input is not sanitized');
      expect(body).toContain('Promise rejection not handled');
    });

    it('should not include suggested fix if empty', () => {
      const noSuggestResult: MRReviewResult = {
        ...baseResult,
        findings: [
          {
            id: 'finding-1',
            severity: 'low',
            category: 'style',
            title: 'Minor issue',
            description: 'Just a note',
            file: 'src/app.ts',
            line: 1,
            suggestedFix: '',
            fixable: false
          }
        ]
      };

      const body = formatReviewBody(noSuggestResult);

      expect(body).not.toContain('**Suggested fix:**');
    });
  });
});
